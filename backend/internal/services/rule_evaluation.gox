package services

import (
	"context"
	"fmt"
	"strconv"
	
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
	"set-and-trend/backend/internal/db"
	"set-and-trend/backend/internal/repositories"
	"set-and-trend/backend/internal/rules"
)

type RuleEvaluationService struct {
	candleRepo      *repositories.CandleRepository
	indicatorRepo   *repositories.IndicatorRepository
	ruleResultRepo  *repositories.RuleResultRepository
}

func NewRuleEvaluationService(
	candleRepo *repositories.CandleRepository,
	indicatorRepo *repositories.IndicatorRepository,
	ruleResultRepo *repositories.RuleResultRepository,
) *RuleEvaluationService {
	return &RuleEvaluationService{
		candleRepo:     candleRepo,
		indicatorRepo:  indicatorRepo,
		ruleResultRepo: ruleResultRepo,
	}
}

// EvaluateCandle performs rule evaluation for a single candle
// This is the orchestration layer - pulls data, evaluates, persists

func (s *RuleEvaluationService) EvaluateCandle(
	ctx context.Context,
	candleID uuid.UUID,
) error {
	// 1. Load candle data
	candle, err := s.candleRepo.GetCandleByID(ctx, candleID)
	if err != nil {
		return fmt.Errorf("failed to load candle: %w", err)
	}

	// 2. Load indicators
	indicator, err := s.indicatorRepo.GetIndicatorByCandleID(ctx, candleID)
	if err != nil {
		return fmt.Errorf("failed to load indicators: %w", err)
	}

	// 3. Convert to rule evaluation types
	ruleCandle, err := s.convertToRuleCandle(*candle)
	if err != nil {
		return fmt.Errorf("failed to convert candle: %w", err)
	}

	ruleIndicators, err := s.convertToRuleIndicators(ctx, indicator, candle.TimestampUTC)
	if err != nil {
		return fmt.Errorf("failed to convert indicators: %w", err)
	}

	// 4. Evaluate all rules
	results := rules.EvaluateAllRules(ruleCandle, ruleIndicators)

	// 5. Persist results
	for ruleCode, result := range results {
		err := s.ruleResultRepo.CreateRuleResult(ctx, repositories.RuleResultCreateParams{
			RuleCode:   ruleCode,
			CandleID:   candleID,
			Result:     result.Result,
			Confidence: result.Confidence,
		})
		if err != nil {
			log.Warn().
				Err(err).
				Str("rule_code", string(ruleCode)).
				Str("candle_id", candleID.String()).
				Msg("Failed to persist rule result")
			// Continue with other rules
		}
	}

	log.Info().
		Str("candle_id", candleID.String()).
		Int("rules_evaluated", len(results)).
		Msg("Rule evaluation complete")

	return nil
}



// Helper: Convert repository candle to rules candle
 rules.Candle{
		Open:         open,
		High:         high,
		Low:          low,
		Close:        close,
		TimestampUTC: c.TimestampUTC,
	}, nil
}

// Helper: Convert repository indicator to rules indicator
func (s *RuleEvaluationService) convertToRuleIndicators(i *repositories.Indicator) (rules.Indicators, error) {
	ema20, err := strconv.ParseFloat(i.EMA20, 64)
	if err != nil {
		return rules.Indicators{}, err
	}
	ema50, err := strconv.ParseFloat(i.EMA50, 64)
	if err != nil {
		return rules.Indicators{}, err
	}
	ema200, err := strconv.ParseFloat(i.EMA200, 64)
	if err != nil {
		return rules.Indicators{}, err
	}

	// TODO: Need to fetch previous candle's EMA50 for EMA50Prev
	// For now, leaving as nil (rule will fail gracefully)

	return rules.Indicators{
		EMA20:     ema20,
		EMA50:     ema50,
		EMA200:    ema200,
		EMA50Prev: nil, // TODO: Implement properly
		// ... rest of fields
	}, nil
}
