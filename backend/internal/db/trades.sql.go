// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trades.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createTrade = `-- name: CreateTrade :one
INSERT INTO trades (
    id,
    user_id,
    account_id,
    candle_id,
    symbol,
    timeframe,
    setup_timestamp_utc,
    account_balance_at_setup,
    leverage_at_setup,
    max_risk_per_trade_pct_at_setup,
    timezone_at_setup,
    bias,
    planned_entry,
    planned_sl,
    planned_tp,
    planned_rr,
    planned_risk_pct,
    planned_risk_amount,
    planned_position_size,
    reason_for_trade,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, NOW()
)
RETURNING id, user_id, account_id, candle_id, symbol, timeframe, setup_timestamp_utc, account_balance_at_setup, leverage_at_setup, max_risk_per_trade_pct_at_setup, timezone_at_setup, bias, planned_entry, planned_sl, planned_tp, planned_rr, planned_risk_pct, planned_risk_amount, planned_position_size, reason_for_trade, actual_entry, actual_sl, actual_tp, actual_risk_pct, actual_risk_amount, actual_position_size, execution_timestamp_utc, close_timestamp_utc, close_price, result, pips_gained, money_gained, rr_realized, duration_seconds, session, created_at
`

type CreateTradeParams struct {
	ID                        uuid.UUID          `json:"id"`
	UserID                    uuid.UUID          `json:"user_id"`
	AccountID                 uuid.UUID          `json:"account_id"`
	CandleID                  uuid.UUID          `json:"candle_id"`
	Symbol                    string             `json:"symbol"`
	Timeframe                 string             `json:"timeframe"`
	SetupTimestampUtc         pgtype.Timestamptz `json:"setup_timestamp_utc"`
	AccountBalanceAtSetup     decimal.Decimal    `json:"account_balance_at_setup"`
	LeverageAtSetup           int32              `json:"leverage_at_setup"`
	MaxRiskPerTradePctAtSetup decimal.Decimal    `json:"max_risk_per_trade_pct_at_setup"`
	TimezoneAtSetup           string             `json:"timezone_at_setup"`
	Bias                      TradeBias          `json:"bias"`
	PlannedEntry              decimal.Decimal    `json:"planned_entry"`
	PlannedSl                 decimal.Decimal    `json:"planned_sl"`
	PlannedTp                 decimal.Decimal    `json:"planned_tp"`
	PlannedRr                 decimal.Decimal    `json:"planned_rr"`
	PlannedRiskPct            decimal.Decimal    `json:"planned_risk_pct"`
	PlannedRiskAmount         decimal.Decimal    `json:"planned_risk_amount"`
	PlannedPositionSize       decimal.Decimal    `json:"planned_position_size"`
	ReasonForTrade            string             `json:"reason_for_trade"`
}

func (q *Queries) CreateTrade(ctx context.Context, arg CreateTradeParams) (Trade, error) {
	row := q.db.QueryRow(ctx, createTrade,
		arg.ID,
		arg.UserID,
		arg.AccountID,
		arg.CandleID,
		arg.Symbol,
		arg.Timeframe,
		arg.SetupTimestampUtc,
		arg.AccountBalanceAtSetup,
		arg.LeverageAtSetup,
		arg.MaxRiskPerTradePctAtSetup,
		arg.TimezoneAtSetup,
		arg.Bias,
		arg.PlannedEntry,
		arg.PlannedSl,
		arg.PlannedTp,
		arg.PlannedRr,
		arg.PlannedRiskPct,
		arg.PlannedRiskAmount,
		arg.PlannedPositionSize,
		arg.ReasonForTrade,
	)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CandleID,
		&i.Symbol,
		&i.Timeframe,
		&i.SetupTimestampUtc,
		&i.AccountBalanceAtSetup,
		&i.LeverageAtSetup,
		&i.MaxRiskPerTradePctAtSetup,
		&i.TimezoneAtSetup,
		&i.Bias,
		&i.PlannedEntry,
		&i.PlannedSl,
		&i.PlannedTp,
		&i.PlannedRr,
		&i.PlannedRiskPct,
		&i.PlannedRiskAmount,
		&i.PlannedPositionSize,
		&i.ReasonForTrade,
		&i.ActualEntry,
		&i.ActualSl,
		&i.ActualTp,
		&i.ActualRiskPct,
		&i.ActualRiskAmount,
		&i.ActualPositionSize,
		&i.ExecutionTimestampUtc,
		&i.CloseTimestampUtc,
		&i.ClosePrice,
		&i.Result,
		&i.PipsGained,
		&i.MoneyGained,
		&i.RrRealized,
		&i.DurationSeconds,
		&i.Session,
		&i.CreatedAt,
	)
	return i, err
}

const createTradeExecution = `-- name: CreateTradeExecution :one
INSERT INTO trade_executions (
    id,
    trade_id,
    event_type,
    price,
    position_size,
    pnl,
    pnl_pips,
    executed_at,
    session,
    reason
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, trade_id, event_type, price, position_size, executed_at, session, reason, slippage_pips, pnl, pnl_pips, created_at
`

type CreateTradeExecutionParams struct {
	ID           uuid.UUID          `json:"id"`
	TradeID      uuid.UUID          `json:"trade_id"`
	EventType    ExecutionEventType `json:"event_type"`
	Price        decimal.Decimal    `json:"price"`
	PositionSize decimal.Decimal    `json:"position_size"`
	Pnl          decimal.Decimal    `json:"pnl"`
	PnlPips      decimal.Decimal    `json:"pnl_pips"`
	ExecutedAt   pgtype.Timestamptz `json:"executed_at"`
	Session      NullSessionType    `json:"session"`
	Reason       pgtype.Text        `json:"reason"`
}

func (q *Queries) CreateTradeExecution(ctx context.Context, arg CreateTradeExecutionParams) (TradeExecution, error) {
	row := q.db.QueryRow(ctx, createTradeExecution,
		arg.ID,
		arg.TradeID,
		arg.EventType,
		arg.Price,
		arg.PositionSize,
		arg.Pnl,
		arg.PnlPips,
		arg.ExecutedAt,
		arg.Session,
		arg.Reason,
	)
	var i TradeExecution
	err := row.Scan(
		&i.ID,
		&i.TradeID,
		&i.EventType,
		&i.Price,
		&i.PositionSize,
		&i.ExecutedAt,
		&i.Session,
		&i.Reason,
		&i.SlippagePips,
		&i.Pnl,
		&i.PnlPips,
		&i.CreatedAt,
	)
	return i, err
}

const getTradeByID = `-- name: GetTradeByID :one
SELECT id, user_id, account_id, candle_id, symbol, timeframe, setup_timestamp_utc, account_balance_at_setup, leverage_at_setup, max_risk_per_trade_pct_at_setup, timezone_at_setup, bias, planned_entry, planned_sl, planned_tp, planned_rr, planned_risk_pct, planned_risk_amount, planned_position_size, reason_for_trade, actual_entry, actual_sl, actual_tp, actual_risk_pct, actual_risk_amount, actual_position_size, execution_timestamp_utc, close_timestamp_utc, close_price, result, pips_gained, money_gained, rr_realized, duration_seconds, session, created_at FROM trades WHERE id = $1
`

func (q *Queries) GetTradeByID(ctx context.Context, id uuid.UUID) (Trade, error) {
	row := q.db.QueryRow(ctx, getTradeByID, id)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CandleID,
		&i.Symbol,
		&i.Timeframe,
		&i.SetupTimestampUtc,
		&i.AccountBalanceAtSetup,
		&i.LeverageAtSetup,
		&i.MaxRiskPerTradePctAtSetup,
		&i.TimezoneAtSetup,
		&i.Bias,
		&i.PlannedEntry,
		&i.PlannedSl,
		&i.PlannedTp,
		&i.PlannedRr,
		&i.PlannedRiskPct,
		&i.PlannedRiskAmount,
		&i.PlannedPositionSize,
		&i.ReasonForTrade,
		&i.ActualEntry,
		&i.ActualSl,
		&i.ActualTp,
		&i.ActualRiskPct,
		&i.ActualRiskAmount,
		&i.ActualPositionSize,
		&i.ExecutionTimestampUtc,
		&i.CloseTimestampUtc,
		&i.ClosePrice,
		&i.Result,
		&i.PipsGained,
		&i.MoneyGained,
		&i.RrRealized,
		&i.DurationSeconds,
		&i.Session,
		&i.CreatedAt,
	)
	return i, err
}

const getTradeExecutions = `-- name: GetTradeExecutions :many
SELECT id, trade_id, event_type, price, position_size, executed_at, session, reason, slippage_pips, pnl, pnl_pips, created_at FROM trade_executions
WHERE trade_id = $1
ORDER BY executed_at ASC
`

func (q *Queries) GetTradeExecutions(ctx context.Context, tradeID uuid.UUID) ([]TradeExecution, error) {
	rows, err := q.db.Query(ctx, getTradeExecutions, tradeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TradeExecution
	for rows.Next() {
		var i TradeExecution
		if err := rows.Scan(
			&i.ID,
			&i.TradeID,
			&i.EventType,
			&i.Price,
			&i.PositionSize,
			&i.ExecutedAt,
			&i.Session,
			&i.Reason,
			&i.SlippagePips,
			&i.Pnl,
			&i.PnlPips,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradesByAccountAndCandle = `-- name: GetTradesByAccountAndCandle :many
SELECT id, user_id, account_id, candle_id, symbol, timeframe, setup_timestamp_utc, account_balance_at_setup, leverage_at_setup, max_risk_per_trade_pct_at_setup, timezone_at_setup, bias, planned_entry, planned_sl, planned_tp, planned_rr, planned_risk_pct, planned_risk_amount, planned_position_size, reason_for_trade, actual_entry, actual_sl, actual_tp, actual_risk_pct, actual_risk_amount, actual_position_size, execution_timestamp_utc, close_timestamp_utc, close_price, result, pips_gained, money_gained, rr_realized, duration_seconds, session, created_at FROM trades
WHERE account_id = $1 AND candle_id = $2
ORDER BY created_at DESC
`

type GetTradesByAccountAndCandleParams struct {
	AccountID uuid.UUID `json:"account_id"`
	CandleID  uuid.UUID `json:"candle_id"`
}

func (q *Queries) GetTradesByAccountAndCandle(ctx context.Context, arg GetTradesByAccountAndCandleParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, getTradesByAccountAndCandle, arg.AccountID, arg.CandleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CandleID,
			&i.Symbol,
			&i.Timeframe,
			&i.SetupTimestampUtc,
			&i.AccountBalanceAtSetup,
			&i.LeverageAtSetup,
			&i.MaxRiskPerTradePctAtSetup,
			&i.TimezoneAtSetup,
			&i.Bias,
			&i.PlannedEntry,
			&i.PlannedSl,
			&i.PlannedTp,
			&i.PlannedRr,
			&i.PlannedRiskPct,
			&i.PlannedRiskAmount,
			&i.PlannedPositionSize,
			&i.ReasonForTrade,
			&i.ActualEntry,
			&i.ActualSl,
			&i.ActualTp,
			&i.ActualRiskPct,
			&i.ActualRiskAmount,
			&i.ActualPositionSize,
			&i.ExecutionTimestampUtc,
			&i.CloseTimestampUtc,
			&i.ClosePrice,
			&i.Result,
			&i.PipsGained,
			&i.MoneyGained,
			&i.RrRealized,
			&i.DurationSeconds,
			&i.Session,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradesByUserID = `-- name: GetTradesByUserID :many
SELECT id, user_id, account_id, candle_id, symbol, timeframe, setup_timestamp_utc, account_balance_at_setup, leverage_at_setup, max_risk_per_trade_pct_at_setup, timezone_at_setup, bias, planned_entry, planned_sl, planned_tp, planned_rr, planned_risk_pct, planned_risk_amount, planned_position_size, reason_for_trade, actual_entry, actual_sl, actual_tp, actual_risk_pct, actual_risk_amount, actual_position_size, execution_timestamp_utc, close_timestamp_utc, close_price, result, pips_gained, money_gained, rr_realized, duration_seconds, session, created_at FROM trades 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetTradesByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

func (q *Queries) GetTradesByUserID(ctx context.Context, arg GetTradesByUserIDParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, getTradesByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CandleID,
			&i.Symbol,
			&i.Timeframe,
			&i.SetupTimestampUtc,
			&i.AccountBalanceAtSetup,
			&i.LeverageAtSetup,
			&i.MaxRiskPerTradePctAtSetup,
			&i.TimezoneAtSetup,
			&i.Bias,
			&i.PlannedEntry,
			&i.PlannedSl,
			&i.PlannedTp,
			&i.PlannedRr,
			&i.PlannedRiskPct,
			&i.PlannedRiskAmount,
			&i.PlannedPositionSize,
			&i.ReasonForTrade,
			&i.ActualEntry,
			&i.ActualSl,
			&i.ActualTp,
			&i.ActualRiskPct,
			&i.ActualRiskAmount,
			&i.ActualPositionSize,
			&i.ExecutionTimestampUtc,
			&i.CloseTimestampUtc,
			&i.ClosePrice,
			&i.Result,
			&i.PipsGained,
			&i.MoneyGained,
			&i.RrRealized,
			&i.DurationSeconds,
			&i.Session,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTradeClosure = `-- name: UpdateTradeClosure :exec
UPDATE trades
SET
    close_timestamp_utc = $2,
    close_price = $3,
    result = $4,
    pips_gained = $5,
    money_gained = $6,
    rr_realized = $7,
    duration_seconds = $8,
    session = $9
WHERE id = $1
`

type UpdateTradeClosureParams struct {
	ID                uuid.UUID          `json:"id"`
	CloseTimestampUtc pgtype.Timestamptz `json:"close_timestamp_utc"`
	ClosePrice        decimal.Decimal    `json:"close_price"`
	Result            NullTradeResult    `json:"result"`
	PipsGained        decimal.Decimal    `json:"pips_gained"`
	MoneyGained       decimal.Decimal    `json:"money_gained"`
	RrRealized        decimal.Decimal    `json:"rr_realized"`
	DurationSeconds   pgtype.Int4        `json:"duration_seconds"`
	Session           NullSessionType    `json:"session"`
}

func (q *Queries) UpdateTradeClosure(ctx context.Context, arg UpdateTradeClosureParams) error {
	_, err := q.db.Exec(ctx, updateTradeClosure,
		arg.ID,
		arg.CloseTimestampUtc,
		arg.ClosePrice,
		arg.Result,
		arg.PipsGained,
		arg.MoneyGained,
		arg.RrRealized,
		arg.DurationSeconds,
		arg.Session,
	)
	return err
}

const updateTradeExecution = `-- name: UpdateTradeExecution :exec
UPDATE trades
SET
    actual_entry = $2,
    actual_sl = $3,
    actual_tp = $4,
    actual_risk_pct = $5,
    actual_risk_amount = $6,
    actual_position_size = $7,
    execution_timestamp_utc = $8
WHERE id = $1
`

type UpdateTradeExecutionParams struct {
	ID                    uuid.UUID          `json:"id"`
	ActualEntry           decimal.Decimal    `json:"actual_entry"`
	ActualSl              decimal.Decimal    `json:"actual_sl"`
	ActualTp              decimal.Decimal    `json:"actual_tp"`
	ActualRiskPct         decimal.Decimal    `json:"actual_risk_pct"`
	ActualRiskAmount      decimal.Decimal    `json:"actual_risk_amount"`
	ActualPositionSize    decimal.Decimal    `json:"actual_position_size"`
	ExecutionTimestampUtc pgtype.Timestamptz `json:"execution_timestamp_utc"`
}

func (q *Queries) UpdateTradeExecution(ctx context.Context, arg UpdateTradeExecutionParams) error {
	_, err := q.db.Exec(ctx, updateTradeExecution,
		arg.ID,
		arg.ActualEntry,
		arg.ActualSl,
		arg.ActualTp,
		arg.ActualRiskPct,
		arg.ActualRiskAmount,
		arg.ActualPositionSize,
		arg.ExecutionTimestampUtc,
	)
	return err
}
